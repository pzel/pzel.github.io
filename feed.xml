<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Simon Zelazny's Blog</title>
    <description></description>
    <link>http://pzel.github.io</link>
    <atom:link href="http://pzel.github.io/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>For focused reading, disconnect wifi</title>
        <description>
	&lt;p&gt;Today I had a 50-page PDF whitepaper to read. I didn't know how long it was
going to take, and — wanting to conserve my laptop battery charge – I disabled
my wifi. It took me suprisingly little time to skim the paper and dig into the
more relevant parts in detail, taking some notes as I went along.&lt;/p&gt;

&lt;p&gt;During the ~2 hours it took me to work through the document, I tried to access
the Internet about ten times. Either by clicking a link in the whitepaper
itself, or trying to follow up on a tangential thought with some info
online. But!  My wifi was switched off, and I'd need to click the network
manager icon to re-connect to the net. I chose not to do that, and instead
continue reading.&lt;/p&gt;

&lt;p&gt;Each time my impulse to access information was frustrated, I realized that &lt;em&gt;had
I been online&lt;/em&gt;, I would have wasted precious minutes reading
tangentially-related web pages, and then some more time again, trying to get
back to reading the original PDF, reestablishing the reading context and
exerting willpower to stay in the PDF reader.&lt;/p&gt;

&lt;p&gt;Acting on these distractions would have defintely prevented me from ingesting the
whitepaper in 2 hours.&lt;/p&gt;

&lt;p&gt;After the fact, I realized that what I'd achieved accidentally is the
productivity hack identified by Matt Might as &lt;a href=&quot;http://matt.might.net/articles/cripple-your-technology/&quot;&gt;crippling your
technology&lt;/a&gt;. By
removing functionality from our tools and keeping that which is &lt;em&gt;strictly
necessary&lt;/em&gt; for completing the task at hand, we remove the 'friction' that gets
in the way of sustained attention. Yes, we do &quot;lose&quot; some capabilities, but we
make up for it by making it easier for ourselves to focus on the goal.&lt;/p&gt;

&lt;p&gt;I'll try to keep this technique in my tool-belt, especially when I need long
periods of focus.&lt;/p&gt;

&lt;p&gt;Apart from Matt Might's productivity writings, a lot more in this vein can be
found in &lt;a href=&quot;http://www.calnewport.com/blog/&quot;&gt;Cal Newport&lt;/a&gt;'s books &amp;amp; blog posts.&lt;/p&gt;

	</description>
        <pubDate>Wed, 02 Oct 2019 00:00:00 +0200</pubDate>
        <link>http://pzel.github.io/til/2019/10/02/For-focused-reading,-disconnect-wifi.html</link>
        <guid isPermaLink="true">http://pzel.github.io/til/2019/10/02/For-focused-reading,-disconnect-wifi.html</guid>
      </item>
    
      <item>
        <title>Plain text &amp; un*x tools are still the best</title>
        <description>
	&lt;p&gt;I did some freelance work for a friendly company that had a problem with its
production dataset. They had a Postgres database, running on a 1TB drive,
holding historic data in a ~500GB table.&lt;/p&gt;

&lt;p&gt;The historic data wasn't needed for anything aside from archival reasons, so
the developers had tried — in between feature work — to remove the old rows
while maintaining DB uptime. Unfortunately, all their previous attempts at
clearing out obsolete data had failed.&lt;/p&gt;

&lt;p&gt;Here's what they tried (on clones of the production VM):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DELETE FROM samples WHERE timestamp &amp;lt; 1234567890&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VACUUM&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VACUUM FULL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;INSERT INTO new_samples SELECT * FROM samples WHERE (..)&lt;/code&gt;,
followed by &lt;code&gt;TRUNCATE TABLE samples&lt;/code&gt; and rename&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;All of these experiments failed to inspire confidence, as they either filled up
the available hard drive space with temporary data, or took so long that the
potential downtime was deemed unacceptable (looking at you, &lt;code&gt;VACUUM FULL&lt;/code&gt;). In
particular, any operation that tried to rebuild the &lt;code&gt;samples&lt;/code&gt; table afresh
would fail. This was due to the fact that the disk was too small to hold two
copies of the table, as dictated by the atomicity requirement of SQL
operations.&lt;/p&gt;

&lt;p&gt;After some experimentation, we determined that the fastest way to achieve our
goals of deleting old data, slimming down index bloat, and reclaiming space for the
OS, was to:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;export the entire DB to a text file of SQL statements (a.k.a a &lt;code&gt;dump&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;remove the existing database completely&lt;/li&gt;
&lt;li&gt;clean up the dump in text form&lt;/li&gt;
&lt;li&gt;import the trimmed-down dump into a fresh database&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;This operation proved to be the fastest and most efficient in terms of
disk-space required, although we were forced to incur downtime.&lt;/p&gt;

&lt;h2&gt;The joy of AWK&lt;/h2&gt;

&lt;p&gt;A concise AWK script was perfect for the job:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.   BEGIN { in_samples=0; min_ts=1514764800; }
2.   /^\\.$/ { if (in_samples==1) { in_samples=0; } }
3.   // {
4.     if (in_samples) {
5.       if ($1 &amp;gt;= min_ts) { print } else { } ;
6.     } else {
7.       print
8.     }
9.   }
10.  /COPY public.samples/ { in_samples=1; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In short, the script can be in 2 states:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;in_samples := 0 | 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It starts out in &lt;code&gt;in_samples=0&lt;/code&gt; (&lt;code&gt;1.&lt;/code&gt;), and copies over every line of text
(&lt;code&gt;7.&lt;/code&gt;). If it finds the first line of the beginning of the &lt;code&gt;samples&lt;/code&gt; table
(&lt;code&gt;10.&lt;/code&gt;), it switches to &lt;code&gt;in_samples=1&lt;/code&gt;. In this state, it will only copy over
samples that are NEWER than January 1, 2018 (&lt;code&gt;5.&lt;/code&gt;). If it finds the
end-of-table-data marker and is &lt;code&gt;in_samples&lt;/code&gt;, it will exit this state
(&lt;code&gt;2.&lt;/code&gt;). Unless there are two tables in the dump named &lt;code&gt;public.samples&lt;/code&gt; (there
aren't), the script will never enter &lt;code&gt;in_samples=1&lt;/code&gt; again, and will simply copy
over all other rows verbatim (line &lt;code&gt;7.&lt;/code&gt;, again).&lt;/p&gt;

&lt;p&gt;It's important to note that &lt;code&gt;awk&lt;/code&gt; evaluates all clauses in order for every line
of input (except for the special &lt;a href=&quot;https://www.gnu.org/software/gawk/manual/html_node/Using-BEGIN_002fEND.html&quot;&gt;&lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;END&lt;/code&gt;
clauses&lt;/a&gt;),
so some lines of input might 'hit' several awk statements. This is beneficial,
but also means that the order of the clauses is important. (Consider what would
happen if the clause on line &lt;code&gt;10.&lt;/code&gt; had been placed before the clause on line
&lt;code&gt;3.&lt;/code&gt;?)&lt;/p&gt;

&lt;h2&gt;Summing up&lt;/h2&gt;

&lt;p&gt;The entire operation of &lt;code&gt;pg_dumpall&lt;/code&gt;, &lt;code&gt;awk&lt;/code&gt;, and &lt;code&gt;psql&lt;/code&gt; import took around 3
hours, which was acceptable downtime for this database as part of scheduled
nighttime maintenance. The space taken up by the Postgres &lt;code&gt;data&lt;/code&gt; directory went
down from ~760GB to ~200GB.&lt;/p&gt;

&lt;p&gt;That day I learned that plain text is &lt;strong&gt;still&lt;/strong&gt; the &lt;em&gt;lingua franca&lt;/em&gt; of UN*X,
and that 40-year-old tools are still excellent at what they were built to do.&lt;/p&gt;

	</description>
        <pubDate>Sat, 06 Jul 2019 00:00:00 +0200</pubDate>
        <link>http://pzel.github.io/til/2019/07/06/Plain-text-&amp;-un-x-tools-are-still-the-best.html</link>
        <guid isPermaLink="true">http://pzel.github.io/til/2019/07/06/Plain-text-&amp;-un-x-tools-are-still-the-best.html</guid>
      </item>
    
      <item>
        <title>Ruby apps under runit: notes to self</title>
        <description>
	&lt;p&gt;I was recently migrating nearly ten-year-old Ruby software from an Ubuntu 10:04
VM to something more recent. It took me way longer than I expected, due to two
major snags.&lt;/p&gt;

&lt;h2&gt;Snag one: Bundler and per-user runsvdir&lt;/h2&gt;

&lt;p&gt;The apps in their original Lucid Lynx setting were run from a bash script that
resembled this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while (/bin/true); do
  (bundle exec 'thin -C config_foo.yml -R config.ru start' 2&amp;gt;&amp;amp;1)
  echo &quot;Server died at `date`. Respawning..&quot; &amp;gt;&amp;amp;2
  sleep 2
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The app stayed up for years, so I guess this unsophisticated approach was good
enough. For ease of deployment (and improved logging, see point #2 below), I
decided to move all ruby web apps on this VPS to a user-local
&lt;a href=&quot;http://smarden.org/runit/&quot;&gt;runit&lt;/a&gt; supervision tree.&lt;/p&gt;

&lt;p&gt;In practice, this means that there's a &lt;code&gt;/etc/service/webuser-sv&lt;/code&gt; directory,
containing a runit service which launches a nested &lt;code&gt;runsvdir&lt;/code&gt; program as the
&lt;code&gt;webuser-sv&lt;/code&gt; user.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /etc/service/webuser-sv
#!/bin/sh
exec 2&amp;gt;&amp;amp;1
exec chpst -uwebuser runsvdir /home/webuser/service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, I can define all of &lt;code&gt;webuser&lt;/code&gt;'s ruby apps as entries under
&lt;code&gt;/home/webuser/service/*&lt;/code&gt;, and have them supervised without bash hackery.&lt;/p&gt;

&lt;p&gt;The snag was that the apps would crash with this error, but only when run as
part of the runit supervision tree:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2019-06-25_11:27:37.51241 `/` is not writable.
2019-06-25_11:27:37.51244 Bundler will use `/tmp/bundler/home/unknown' as your home directory temporarily.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But if I ran the runit &lt;code&gt;run&lt;/code&gt; scripts by hand, the apps started up and worked correctly.&lt;/p&gt;

&lt;p&gt;After a lot of false starts and pointless github issue rabbit-holes, I realized
that the &lt;code&gt;runsvdir&lt;/code&gt; process managing the user-local supervision tree was
launched with &lt;a href=&quot;http://smarden.org/runit/chpst.8.html&quot;&gt;chpst&lt;/a&gt; by the master
runit supervisor. Specifying a UID for &lt;code&gt;chpst&lt;/code&gt; with &lt;code&gt;-u&lt;/code&gt; does not automatically
mean that the profile for this user gets loaded. In particular, not even
&lt;code&gt;$HOME&lt;/code&gt; was configured in the runit supervisor environment.&lt;/p&gt;

&lt;p&gt;Bundler needs '$HOME' to be set, otherwise it gets confused.&lt;/p&gt;

&lt;p&gt;Hence, my runit run files now look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exec 2&amp;gt;&amp;amp;1
export RUBYOPT=-W0
export HOME=/home/web
export LANG=en_US.UTF-8
cd /home/web/webapp.1.com
exec bundle exec rackup -E production -s thin -o 0.0.0.0 -p 4567 config.ru
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Duplication could be further removed by setting up an &lt;code&gt;envdir&lt;/code&gt;, and running the
user-level &lt;code&gt;runsvdir&lt;/code&gt; with this envdir passed to &lt;code&gt;chpst&lt;/code&gt; ...  but the above
solution is good enough for today.&lt;/p&gt;

&lt;h2&gt;Snag two: Don't ever redirect $stdin and $stderr&lt;/h2&gt;

&lt;p&gt;Runit has a wonderfully clean approach to logging, predating the &lt;a href=&quot;https://12factor.net/&quot;&gt;12-factor
app&lt;/a&gt;, but very similar in spirit. Run your app in the
foreground, and pipe its output to your log processor. This way applications
themselves never need to concern themselves with logging frameworks and
infrastructure.&lt;/p&gt;

&lt;p&gt;Now ten years ago, when I launched these apps from bash scripts, they apps
themselves &lt;strong&gt;definitely&lt;/strong&gt; needed to know what to do with their logs. Hence,
these two monstrous lines:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;settings.configure do |s|
    $stdout = File.open(&quot;log/log_out.txt&quot;,&quot;a&quot;)
    $stderr = File.open(&quot;log/log_err.txt&quot;,&quot;a&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These two lines had me stumped as to why an app was silently crashing at
startup with nothing in the runit logs. After removing the two lines I was
able to see the real reason for the crash (some missing assets).&lt;/p&gt;

&lt;p&gt;Sure, the exception had been logged all along to &lt;code&gt;log/log_err.txt&lt;/code&gt;, but I'd
completely forgotten to look there, expecting the logging to be handled by
runit's log facility.&lt;/p&gt;

&lt;p&gt;Never redirect $stdout and $stdin inside the app, kids. Your future self will thank you.&lt;/p&gt;

	</description>
        <pubDate>Tue, 25 Jun 2019 00:00:00 +0200</pubDate>
        <link>http://pzel.github.io/til/2019/06/25/Ruby-apps-under-runit-notes-to-self.html</link>
        <guid isPermaLink="true">http://pzel.github.io/til/2019/06/25/Ruby-apps-under-runit-notes-to-self.html</guid>
      </item>
    
      <item>
        <title>How I learned to never match on os:cmd output</title>
        <description>
	&lt;p&gt;A late change in requirements from a customer had me scrambling to switch an
HDFS connector script — from a &lt;a href=&quot;https://pypi.org/project/hdfs/&quot;&gt;Python program&lt;/a&gt; — to the standard Hadoop
tool &lt;code&gt;hdfs&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The application that was launching the connector script was written in Erlang,
and was responsible for uploading some files to an HDFS endpoint, like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UploadCmd = lists:flatten(io_lib:format(&quot;hdfs put ~p ~p&quot;, [Here, There])),
&quot;&quot; = os:cmd(UploadCmd),
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This was all fine and dandy when the &lt;code&gt;UploadCmd&lt;/code&gt; was implemented in full by
me. When I switched out the Python script for the &lt;code&gt;hdfs&lt;/code&gt; command, all my tests
continued to work, and the data was indeed being written successfully to my
&lt;a href=&quot;http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-common/CLIMiniCluster.html&quot;&gt;local test hdfs node&lt;/a&gt;. So off to production it went.&lt;/p&gt;

&lt;p&gt;Several hours later I got notified that there's some problems with the new
code. After inspecting the logs it became clear that the &lt;code&gt;hdfs&lt;/code&gt; command was
producing unexpected output (&lt;code&gt;WARN: blah blah took longer than expected (..)&lt;/code&gt;)
and causing the Erlang program to treat the upload operation as failed.&lt;/p&gt;

&lt;p&gt;As is the case for reasonable Erlang applications, the writing process would
crash upon a failed match, then restart and attempt to continue where it left
off — by trying to upload &lt;code&gt;Here&lt;/code&gt; to &lt;code&gt;There&lt;/code&gt;.  Now, this operation kept
legitimately failing, because it had in fact succeeded the first time, and HDFS
would not allow us to overwrite &lt;code&gt;There&lt;/code&gt; (unless we added a &lt;code&gt;-f&lt;/code&gt; flag to &lt;code&gt;put&lt;/code&gt;).&lt;/p&gt;

&lt;h3&gt;The solution&lt;/h3&gt;

&lt;p&gt;The quick-and-dirty solution was to wrap the &lt;code&gt;UploadCmd&lt;/code&gt; in a script that
captured the exit code, and then printed it out at the end, like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sh -c '{UploadCmd}; RES=$?; echo; echo $RES'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, your Erlang code can match on the last line of the output and interpret it
as a integer exit code. Not the most elegant of solutions, but elegant enough
to work around &lt;a href=&quot;http://erlang.org/doc/man/os.html#cmd-1&quot;&gt;os:cmd/1&lt;/a&gt;'s blindess to exit codes.&lt;/p&gt;

&lt;h3&gt;Lesson learned&lt;/h3&gt;

&lt;p&gt;The UNIX way states that programs should be silent on success and vocal on
error. Sadly, many applications don't follow the UNIX way, and the bigger the
application at hand, the higher the probability that one of its dependencies
will use STDOUT or STDERR as its own personal scratchpad.&lt;/p&gt;

&lt;p&gt;My lesson: &lt;strong&gt;never rely on os:cmd/1 output in production code&lt;/strong&gt;, unless the
command you're running is fully under your control, and you can be certain that
its outputs are completely and exhaustively specified by you.&lt;/p&gt;

&lt;p&gt;I do heavily rely on os:cmd output in test code, and I have no intention of
stopping. Early feedback about unexpected output is great in tests.&lt;/p&gt;

	</description>
        <pubDate>Tue, 14 May 2019 00:00:00 +0200</pubDate>
        <link>http://pzel.github.io/til/2019/05/14/How-I-learned-to-never-match-on-os-cmd-output.html</link>
        <guid isPermaLink="true">http://pzel.github.io/til/2019/05/14/How-I-learned-to-never-match-on-os-cmd-output.html</guid>
      </item>
    
      <item>
        <title>Uses for traits vs type aliases in Ponylang</title>
        <description>
	&lt;p&gt;I realized today that while both &lt;a href=&quot;https://tutorial.ponylang.io/types/traits-and-interfaces.html&quot;&gt;traits&lt;/a&gt; and &lt;a href=&quot;https://tutorial.ponylang.io/types/type-aliases.html&quot;&gt;type aliases&lt;/a&gt; can be used
to represent a union of types in Pony, each of these solutions has some
characteristics which make sense in different circumstances.&lt;/p&gt;

&lt;h2&gt;Traits: Keeping an interface open&lt;/h2&gt;

&lt;p&gt;Let's say you have the trait &lt;code&gt;UUIDable&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;trait UUIDable
  fun uuid(): UUID
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and you have a method that accepts objects implementing said trait.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  fun register_uuid(thing: UUIDable): RegistrationResult =&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Delcaring the function parameter type like this means that any &lt;code&gt;thing&lt;/code&gt; that has
been declared to implement the trait &lt;code&gt;UUIDable&lt;/code&gt; will be a valid
argument. Inside the method body, we can only call &lt;code&gt;.uuid()&lt;/code&gt; on the &lt;code&gt;thing&lt;/code&gt;, because that's the only method specified by the trait.&lt;/p&gt;

&lt;p&gt;We can take an instance of the class &lt;code&gt;class User is UUIDable&lt;/code&gt;, and pass it to
&lt;code&gt;register_uuid.&lt;/code&gt; When we continue development and add &lt;code&gt;class Invoice is
UUIDable&lt;/code&gt;, no change in any code is required for &lt;code&gt;register_uuid&lt;/code&gt; to also accept
this new class. In fact, we are free to add as many &lt;code&gt;UUIDable&lt;/code&gt; classes to our
codebase, and they'll all work without any changes to &lt;code&gt;register_uuid&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This approach is great when we just want to define a typed contract for our
methods.  However, it does not work when we want to explicitly break
encapsulation and – for example – match on the type of the &lt;code&gt;thing&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fun register_uuid(thing: UUIDable): RegistrationResult =&amp;gt;
  match thing
  | let u: User =&amp;gt; _register_user(u)
  | let i: Invoice =&amp;gt; _register_invoice(i)
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The compiler will complain about this method definition, because it can't know
that &lt;code&gt;User&lt;/code&gt; and &lt;code&gt;Invoice&lt;/code&gt; are the only exising types that satisfy
&lt;code&gt;UUIDable&lt;/code&gt;. For the compiler, this now means that any &lt;code&gt;UUIDable&lt;/code&gt; thing that is
&lt;strong&gt;not&lt;/strong&gt; a &lt;code&gt;User&lt;/code&gt; or an &lt;code&gt;Invoice&lt;/code&gt; will fall through the &lt;code&gt;match&lt;/code&gt;, and so the
resulting output type must also include &lt;code&gt;None&lt;/code&gt;, which represents the 'missed'
case in our &lt;code&gt;match&lt;/code&gt; statment.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;We&lt;/strong&gt; know that the above match is indeed exhaustive. &lt;code&gt;User&lt;/code&gt;s and &lt;code&gt;Invoice&lt;/code&gt;s will
be the only types that satisfy &lt;code&gt;UUIDable&lt;/code&gt;. How can we let the &lt;strong&gt;compiler&lt;/strong&gt; know?&lt;/p&gt;

&lt;h2&gt;Type aliases: explicit and complete enumerations&lt;/h2&gt;

&lt;p&gt;If we want to break encapsulation, and are interested in an exhaustive and
explicit union type, then a type alias gives the compiler enough info to
determine that the match statement is in fact exhaustive:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type UUIDable is (User | Invoice)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;fun register_uuid(thing: UUIDable): RegistrationResult =&amp;gt;
  match thing
  | let u: User =&amp;gt; _register_user(u)
  | let i: Invoice =&amp;gt; _register_invoice(i)
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Different situations will call for different approaches. The type alias
approach means that anytime you add a new &lt;code&gt;UUIDable&lt;/code&gt;, you'll have to redefine
this alias, &lt;em&gt;and&lt;/em&gt; have to go through all your &lt;code&gt;match&lt;/code&gt; statements and add a new
case. The silver lining is that the compiler will tell you which places you
need to modify.&lt;/p&gt;

&lt;p&gt;Also, note that you can still call &lt;code&gt;thing.uuid()&lt;/code&gt; and have it type-check, as
the compiler can determine that all classes belonging to &lt;code&gt;(User | Invoice)&lt;/code&gt;
actually provide this method.&lt;/p&gt;

&lt;h2&gt;Encapsulation vs. exhaustiveness&lt;/h2&gt;

&lt;p&gt;Using traits (or interfaces for even more 'looseness') means that, in the
large, your code will have to conform to the OOO practices of loose coupling,
information hiding, and encapsulation.&lt;/p&gt;

&lt;p&gt;Using union types defined as type aliases means that encapsulation is no longer
possible, but the compiler will guide you in making sure that matches are
exhaustive when you take apart function arguments. This results in the code
looking more 'functional' in the large.&lt;/p&gt;

&lt;p&gt;You can play around with this code in the &lt;a href=&quot;https://playground.ponylang.io/?gist=429dcefd4ebc952c241bbbcaef3104c9&quot;&gt;Pony playground&lt;/a&gt;.&lt;/p&gt;

	</description>
        <pubDate>Sat, 06 Apr 2019 00:00:00 +0200</pubDate>
        <link>http://pzel.github.io/til/2019/04/06/Uses-for-traits-vs-type-aliases-in-Ponylang.html</link>
        <guid isPermaLink="true">http://pzel.github.io/til/2019/04/06/Uses-for-traits-vs-type-aliases-in-Ponylang.html</guid>
      </item>
    
      <item>
        <title>Uncrashable languages aren't</title>
        <description>A trivial observation, with some examples
	&lt;h2&gt;Making buggy situations unrepresentable&lt;/h2&gt;

&lt;p&gt;Programs have &lt;strong&gt;bugs&lt;/strong&gt;. Both creators and end-users of software dislike
bugs. Businesses paying for software development dislike bugs. It's no wonder
that, as the role of software in the world expands, we've become very
interested in minimizing occurrences of bugs.&lt;/p&gt;

&lt;p&gt;One way of reducing bugs is via process: making sure that critical code is
tested to the greatest practical extent. Another way is via construction:
making sure that buggy code is not representable. This could be achieved by
making such code unexpressible in the syntax of a language, or having it fail
the compiler's type check.&lt;/p&gt;

&lt;p&gt;There are two new programming languages that take a principled stance on the
side of &lt;em&gt;non-representability&lt;/em&gt;, by preventing code from crashing wantonly:
&lt;a href=&quot;https://elm-lang.org/&quot;&gt;Elm&lt;/a&gt; and &lt;a href=&quot;https://www.ponylang.io/&quot;&gt;Pony&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Elm does this by eliminating exceptions from language semantics and forcing the
programmer to handle all branches of sum types (i.e your code has to cover all
representable states that it might encounter).&lt;/p&gt;

&lt;p&gt;Pony does this by allowing anonymous exceptions (the &lt;code&gt;error&lt;/code&gt; operator), but
forcing the programmer to deal with them at some point. All functions – apart
from those which are explicitly marked as capable of throwing errors – &lt;em&gt;MUST&lt;/em&gt;
be total and always return a value.&lt;/p&gt;

&lt;h2&gt;A small aside about division by zero&lt;/h2&gt;

&lt;p&gt;Elm used to crash when you tried to divide by zero. Now (I tried version
&lt;code&gt;0.19&lt;/code&gt;), it returns &lt;code&gt;0&lt;/code&gt; for integer division and &lt;code&gt;Infinity&lt;/code&gt; for floating-point
division. The division functions are therefore total.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; 5.0 / 0.0
Infinity : Float
&amp;gt; 5 // 0
0 : Int
&amp;gt; remainderBy 5 0
0 : Int
&amp;gt; modBy 5 0
0 : Int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pony also returns zero when zero is the divisor.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;actor Main                                        //  This code prints:
  new create(env: Env) =&amp;gt;                         //  0
   env.out.print((U32(1) / U32(0)).string())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, Pony also provides &lt;a href=&quot;https://tutorial.ponylang.io/expressions/arithmetic.html&quot;&gt;partial
arithmetic&lt;/a&gt; operators
(&lt;code&gt;/?&lt;/code&gt; for division, &lt;code&gt;+?&lt;/code&gt; for addition, below), for when you explicitly need
integer over/underflows and division-by-zero to be illegal:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;actor Main                                         //  This code prints:
  new create(env: Env) =&amp;gt;                          //  div by zero
    try U32(1) /? U32(0)                           //  overflow
    else env.out.print(&quot;div by zero&quot;)              //  0
    end                                            //  0
    try U8(255) +? U8(1)
    else env.out.print(&quot;overflow&quot;)
    end
   env.out.print((U32(1) / U32(0)).string())
   env.out.print((U8(255) + U8(1)).string())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While returning '0' for divison-by-zero is a controversial topic (yet silent
integer overflows somehow don't generate the same debate), I think it's
reasonable to view this compromise as the necessary cost of eliminating crashes
in our code. More interesting is this: we have just made a
tradeoff between eliminating &lt;strong&gt;crashes&lt;/strong&gt; and &lt;strong&gt;wrong results&lt;/strong&gt;. Having a total
division function eliminates crashes at the cost of allowing wrong results to
propagate. Let's dig into this a bit more.&lt;/p&gt;

&lt;h2&gt;Bugs and the bottom type&lt;/h2&gt;

&lt;p&gt;Taxonomy is supposed to be the lowest form of science, but let's indulge and
distinguish two main types of program misbehavior:&lt;/p&gt;

&lt;p&gt;   1) A program (or function) produces output which does not match the
   programmer's intent, design, or specification;&lt;/p&gt;

&lt;p&gt;   2) A program (or function) fails to produce output (e.g. freezes or crashes)&lt;/p&gt;

&lt;p&gt;I hope you'll agree that eliminating 'bugs' caused by the first type of error
is not an easy feat, and probably not within the scope of a language runtime or
compiler. Carefully designing your data structures to make illegal states
unrepresentable may go a long way towards eliminating failures of this kind, as
will a good testing regimen. Let's not delve deeper into this category and
focus on the second one: &lt;strong&gt;functions that crash and never return&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;The wikipedia article on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bottom_type&quot;&gt;Bottom
Type&lt;/a&gt; makes for an intersting
read. It's nice to conceive of &lt;code&gt;⊥&lt;/code&gt; as a hole in the program, where execution
stops and meaning collapses. Since the bottom type is a subtype of every type,
theoretically any function can return the 'bottom value' — although returning
the 'bottom value' acutally means &lt;em&gt;never returning at all&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;My claim is that while some languages, like Haskell or Rust, might explicitly
embrace the existence of &lt;code&gt;⊥&lt;/code&gt;, languages that prevent programmers from
'invoking' the bottom type will always contain inconsistencies (I'm leaving
dependently-typed languages out of this). Below are two examples.&lt;/p&gt;

&lt;h2&gt;Broken promises and infinite loops&lt;/h2&gt;

&lt;p&gt;Elm's promise is that an application written in Elm will never crash, unless
there is a bug in the Elm runtime. &lt;a href=&quot;https://medium.com/@eeue56/top-6-ways-to-make-your-elm-app-crash-at-runtime-562b2fa92d70&quot;&gt;There are articles out
there&lt;/a&gt;
that enumerate the various broken edge-cases (regexp, arrays, json decoding),
but these cases can arguably be construed as bugs in the runtime or mistakes in
library API design. That is, these bugs do not mean that Elm's promise is for
naught.&lt;/p&gt;

&lt;p&gt;However, if you think about it, an infinite loop is a manifestation of the
bottom type just as much as an outright crash, and such a loop is possible in
all Turing-complete languages.&lt;/p&gt;

&lt;p&gt;Here's a legal Elm app that freezes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Browser
import Html exposing (Html, button, div, text)
import Html.Events exposing (onClick)

main =
  Browser.sandbox { init = 0, update = update, view = view }

type Msg = Increment | Decrement

add : Int -&amp;gt; Int
add n =
  add (n+1)

update msg model =
  case msg of
    Increment -&amp;gt;
      add model

    Decrement -&amp;gt;
      model - 1

view model =
  div []
    [ button [ onClick Decrement ] [ text &quot;-&quot; ]
    , div [] [ text (String.fromInt model) ]
    , button [ onClick Increment ] [ text &quot;+&quot; ]
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What will happen when you click the &lt;code&gt;+&lt;/code&gt; button in the browser? This is what:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/bad-elm.png&quot; alt=&quot;Screenshot of browser message saying: 'A web page is slowing down your browser.'&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The loop is hidden in the &lt;code&gt;add&lt;/code&gt; function, which never actually returns an
&lt;code&gt;Int&lt;/code&gt;. Its true return type, in this program, is precisely &lt;code&gt;⊥&lt;/code&gt;. Without
explicitly crashing-and-stopping, we've achieved the logical (and
type-systematic) equivalent: a freeze.&lt;/p&gt;

&lt;h2&gt;Galloping forever and ever&lt;/h2&gt;

&lt;p&gt;The Pony language is susceptible to a similar trick, but we'll have to be a bit
more crafty. First of all, Pony does indeed allow the programmer to 'invoke'
the Bottom Type, by simply using the keyword &lt;code&gt;error&lt;/code&gt; anywhere in a function
body. Using this keyword (or calling a partial function) means that we, the
programmer, now have a choice to make:&lt;/p&gt;

&lt;p&gt;  1) Use &lt;code&gt;try/else&lt;/code&gt; to handle the possibility of error, and return a sensible
  default value&lt;/p&gt;

&lt;p&gt;  2) Mark this function as partial &lt;code&gt;?&lt;/code&gt;, and force callers to deal with the
  possibility of the Bottom Type rearing its head.&lt;/p&gt;

&lt;p&gt;However, we can craft a function that spins endlessly, never exiting, and thus
'returning' the Bottom Type, without the compiler complaining, and without
having to annotate it as partial.&lt;/p&gt;

&lt;p&gt;Interestingly enough, naïve approaches are optimized away by the compiler,
producing surprising result values instead of spinning forever:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;actor Main
  new create(env: Env) =&amp;gt;
    let x = spin(false)
    env.out.print(x.string())

  fun spin(n: Bool): Bool =&amp;gt;
    spin(not n)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before you run this program, think about what, if anything, it should
output. Then, run it and see. Seems like magic to me, but I'm guessing this is
LLVM detecting the oscillation and producing a 'sensible' value.&lt;/p&gt;

&lt;p&gt;We can outsmart the optimizer by farming out the loop to another object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;actor Main
  new create(env: Env) =&amp;gt;
    let t: TarpitTrap = TarpitTrap
    let result = t.spin(true)
    env.out.print(result.string())

class TarpitTrap
  fun spin(n: Bool): Bool =&amp;gt;
    if n then spin(not n)
    else spin(n)
    end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, this program properly freezes forever, as intended. Of course this is just
a contrived demonstration, but one can imagine an analogous situation happening
at run-time, for example when parsing tricky (or malicious) input data.&lt;/p&gt;

&lt;h2&gt;The snake in the garden&lt;/h2&gt;

&lt;p&gt;While I enjoy working both in Elm and Pony, I'm not a particular fan of these
languages' hard-line stance on making sure programs never crash. As long as
infinite loops are expressible in the language, the Bottom Type cannot be
excised.&lt;/p&gt;

&lt;p&gt;Even without concerns somewhat external to our programming language runtime,
such as memory constraints, FFIs, syscalls, or the proverbial admin pulling the
plug on our machine (did this really used to happen?), the humble infinite loop
ensures that non-termination can never be purged from our
(non-dependently-typed) program.&lt;/p&gt;

&lt;p&gt;Instead of focusing on preventing crashes in the small, I think we, as
programmers, should embrace failure and look at how to deal with error from a
higher-level perspective, looking at processes, machines, and entire
systems. Erlang and OTP got this right so many years ago. Ensuring the proper
operation of a system &lt;em&gt;despite&lt;/em&gt; failure is a much more practical goal than
vainly trying to expel the infinitely-looping snake from our software garden.&lt;/p&gt;

	</description>
        <pubDate>Sun, 31 Mar 2019 00:00:00 +0100</pubDate>
        <link>http://pzel.github.io/2019/03/31/Uncrashable-languages-arent.html</link>
        <guid isPermaLink="true">http://pzel.github.io/2019/03/31/Uncrashable-languages-arent.html</guid>
      </item>
    
      <item>
        <title>How to grab all hosts but the first, in Ansible</title>
        <description>
	&lt;p&gt;Today I was trying to figure out how to run a particular ansible play on one
host out of a group, and another play on &lt;em&gt;all the other hosts&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The answer was found in a &lt;a href=&quot;https://grokbase.com/t/gg/ansible-project/14bkjnvrnq/how-to-define-all-hosts-but-first-in-a-group&quot;&gt;mailing group posting from 2014&lt;/a&gt;, but in case
that service goes down, here's my note-to-self on how to do it.&lt;/p&gt;

&lt;p&gt;Let's say you have a group of hosts called &lt;code&gt;stateful_cluster_hosts&lt;/code&gt; in your
inventory.  You'd like to upload &lt;code&gt;files/leader_script.sh.j2&lt;/code&gt; to the first host,
and &lt;code&gt;files/follower_script.sh.j2&lt;/code&gt; to all the others.&lt;/p&gt;

&lt;p&gt;The play for the &lt;strong&gt;leader host&lt;/strong&gt; would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- hosts: stateful_cluster_hosts[0]
  tasks:
  - name: &quot;Upload leader start script&quot;
    template:
      src: files/leader_script.sh.j2
      dest: start.sh
      mode: &quot;u=rwx,g=rx,o=rx&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The play for the &lt;strong&gt;follower hosts&lt;/strong&gt; would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- hosts:  stateful_cluster_hosts:!stateful_cluster_hosts[0]
  tasks:
  - name: &quot;Upload follower start script&quot;
    template:
      src: files/follower_script.sh.j2
      dest: start.sh
      mode: &quot;u=rwx,g=rx,o=rx&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where the sytax &lt;code&gt;list:!list[idx]&lt;/code&gt; means &lt;em&gt;take &lt;code&gt;list&lt;/code&gt;, but filter out
&lt;code&gt;list[idx]&lt;/code&gt;&lt;/em&gt;.&lt;/p&gt;

	</description>
        <pubDate>Wed, 20 Mar 2019 00:00:00 +0100</pubDate>
        <link>http://pzel.github.io/til/2019/03/20/How-to-grab-all-hosts-but-the-first-in-Ansible.html</link>
        <guid isPermaLink="true">http://pzel.github.io/til/2019/03/20/How-to-grab-all-hosts-but-the-first-in-Ansible.html</guid>
      </item>
    
      <item>
        <title>Figuring out a gen_tcp:recv limitation</title>
        <description>In which a suprisingly pernicious framed payload leads to OTP spelunking.
	&lt;h2&gt;The setup: sending a string over TCP&lt;/h2&gt;

&lt;p&gt;Let's say you want to send the ASCII string &lt;code&gt;Fiat lux!&lt;/code&gt; to an Erlang process
listening on the other side of a TCP connection. Not a big deal, right?&lt;/p&gt;

&lt;p&gt;Our sending application is written in Python. Here's what it might look like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#!/usr/bin/env python3
import socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((&quot;127.0.0.1&quot;, 7777))
data_to_send = b&quot;Fiat Lux!&quot;
sock.sendall(data_to_send)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;... and here's the receiving Erlang application:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;erlang&quot;&gt;#!/usr/bin/env escript
main(_) -&amp;gt;
  {ok, L} = gen_tcp:listen(7777, [binary, {active, false}, {reuseaddr, true}]),
  {ok, Sock} = gen_tcp:accept(L),
  {ok, String} = gen_tcp:recv(Sock, 0),
  io:format(&quot;Got string: ~ts~n&quot;, [String]),
  erlang:halt(0).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we start the Erlang receiver (in shell 1), then run the Python sender (in
shell2), we should see the receiver emit the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;$ ./receive.escript
Got string: Fiat Lux!
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, we optimistically sent all our data over TCP from the Python
app, and received all that data, intact, on the other side. What's important
here is that our Erlang socket is in &lt;a href=&quot;http://erlang.org/doc/man/inet.html#ghlink-setopts-2-id215039&quot;&gt;passive
mode&lt;/a&gt;, which
means that incoming TCP data needs to be &lt;code&gt;recv&lt;/code&gt;'d off of the socket. The second
argument in &lt;code&gt;gen_tcp:recv(Sock, 0)&lt;/code&gt; means that we want to read however many
bytes are available to be read from the OS's network stack. In this case all
our data was kindly provided to us in one nice chunk.&lt;/p&gt;

&lt;p&gt;Success! Our real production application will be dealing with much bigger
pieces of data, so it behooves us to test with a larger payload. Let's try a
thousand characters.&lt;/p&gt;

&lt;h2&gt;More data&lt;/h2&gt;

&lt;p&gt;We update the sender and receiver as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#!/usr/bin/env python3
import socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((&quot;127.0.0.1&quot;, 7777))
data_to_send = b'a' * 1000
sock.sendall(data_to_send)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;erlang&quot;&gt;#!/usr/bin/env escript
main(_) -&amp;gt;
  {ok, L} = gen_tcp:listen(7777, [binary, {active, false}, {reusaddr, true}]),
  {ok, Sock} = gen_tcp:accept(L),
  {ok, String} = gen_tcp:recv(Sock, 0),
  io:format(&quot;Got string of length: ~p~n&quot;, [byte_size(String)]),
  erlang:halt(0).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we run our experiment, we see that our Erlang process does indeed get all
&lt;code&gt;1000&lt;/code&gt; bytes. Let's add one more zero to the payload.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#!/usr/bin/env python3
import socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((&quot;127.0.0.1&quot;, 7777))
data_to_send = b'a' * 10000
sock.sendall(data_to_send)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we hit our first snag!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Got string of length: 1460
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aha! Our &lt;code&gt;gen_tcp:recv(Sock, 0)&lt;/code&gt; call asked the OS to give us whatever bytes it
had ready in the TCP buffer, and so that's what we received. TCP is a streaming
protocol, and there is no guarantee that a given sequence of bytes received on
the socket will correspond to a logical message in our application layer. The
low-effort way of handling this issue is by prefixing every logical message on
the TCP socket with a known-width integer, representing the length of the
message in bytes. &quot;Low-effort&quot; sounds like the kind of thing you put in place
when the deadline was yesterday. Onward!&lt;/p&gt;

&lt;p&gt;Let's take our initial string as an example. Instead of sending the following
sequence of &lt;code&gt;9&lt;/code&gt; bytes on the wire:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ascii:     F    i   a    t   ␣    l    u    x   !

Binary:   70  105  97  116  32  108  117  120  33
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We'd first prefix it with an 32-bit integer representing its size in bytes, and
then append the binary, giving &lt;code&gt;13&lt;/code&gt; bytes in total.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ascii:     ␀   ␀  ␀   ␉  F    i   a    t   ␣    l    u    x   !

Binary:    0   0   0   9  70  105  97  116  32  108  117  120  33
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, the first 4 bytes that reach our receiver can be interpreted as the length
of the next logical message. We can use this number to tell &lt;code&gt;gen_tcp:recv&lt;/code&gt; how
many bytes we want to read from the socket.&lt;/p&gt;

&lt;p&gt;To encode an integer into 32 bits, we'll use &lt;a href=&quot;[https://docs.python.org/3/library/struct.html&quot;&gt;Python's struct module&lt;/a&gt;. &lt;code&gt;struct.pack(&quot;&amp;gt;I&quot;, 9)&lt;/code&gt; will do
exactly what we want: encode a 32-bit unsigned Integer (&lt;code&gt;9&lt;/code&gt;, in this case) in
Big-endian (or network) order.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#!/usr/bin/env python3
import socket
import struct
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((&quot;127.0.0.1&quot;, 7777))
data_to_send = b'a' * 10000
header = struct.pack(&quot;&amp;gt;I&quot;, len(data_to_send))
sock.sendall(header + data_to_send)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the decoding side, we'll break up the receiving into two parts:&lt;/p&gt;

&lt;p&gt;1) Read 4 bytes from the socket, interpret these as &lt;code&gt;Header&lt;/code&gt;, a 32-bit unsigned
int.&lt;/p&gt;

&lt;p&gt;2) Read &lt;code&gt;Header&lt;/code&gt; bytes off the socket. The receiving Erlang process will
'block' until that much data is read (or until the other side disconnects). The
received bytes constitute a logical message.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env escript
main(_) -&amp;gt;
  {ok, L} = gen_tcp:listen(7777, [binary, {active, false}, {reuseaddr, true}]),
  {ok, Sock} = gen_tcp:accept(L),
  {ok, &amp;lt;&amp;lt;Header:32&amp;gt;&amp;gt;} = gen_tcp:recv(Sock, 4),
  io:format(&quot;Got header: ~p~n&quot;, [Header]),
  {ok, String} = gen_tcp:recv(Sock, Header),
  io:format(&quot;Got string of length: ~p~n&quot;, [byte_size(String)]),
  erlang:halt(0).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we run our scripts, we'll see the Erlang receiver print the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Got header: 10000
Got string of length: 10000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Success! But apparently, our application needs to handle messages much bigger
than 10 kilobytes. Let's see how far we can take this approach.&lt;/p&gt;

&lt;h2&gt;Yet more data&lt;/h2&gt;

&lt;p&gt;Can we do a megabyte? Ten? A hundred? Let's find out, using the following loop
for the sender:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#!/usr/bin/env python3
import socket
import struct
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((&quot;127.0.0.1&quot;, 7777))
for l in [1000, 1000*1000, 10*1000*1000, 100*1000*1000]:
    data_to_send = b'a' * l
    header = struct.pack(&quot;&amp;gt;I&quot;, len(data_to_send))
    sock.sendall(header + data_to_send)
sock.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;...and a recursive receive function for the receiver:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;erlang&quot;&gt;#!/usr/bin/env escript
recv(Sock) -&amp;gt;
  {ok, &amp;lt;&amp;lt;Header:32&amp;gt;&amp;gt;} = gen_tcp:recv(Sock, 4),
  io:format(&quot;Got header: ~p~n&quot;, [Header]),
  {ok, String} = gen_tcp:recv(Sock, Header),
  io:format(&quot;Got string of length: ~p~n&quot;, [byte_size(String)]),
  recv(Sock).

main(_) -&amp;gt;
  {ok, L} = gen_tcp:listen(7777, [binary, {active, false}, {reuseaddr, true}]),
  {ok, Sock} = gen_tcp:accept(L),
  recv(Sock).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running this will lead to our Erlang process crashing with an interesting message:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Got header: 1000
Got string of length: 1000
Got header: 1000000
Got string of length: 1000000
Got header: 10000000
Got string of length: 10000000
Got header: 100000000
escript: exception error: no match of right hand side value {error,enomem}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;enomem&lt;/code&gt; looks like a strange kind of error indeed. It happens when we get the
100-megabyte header and attempt to read that data off the socket. Let's go spelunking to find out where this error is coming from.&lt;/p&gt;

&lt;h2&gt;Spelunking for &lt;code&gt;{error, enomem}&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;First, let's take a look at &lt;a href=&quot;https://github.com/erlang/otp/blob/master/lib/kernel/src/gen_tcp.erl#L302-L308&quot;&gt;what &lt;code&gt;gen_tcp:recv&lt;/code&gt;
does&lt;/a&gt;
with its arguments. It seems that it checks &lt;code&gt;inet_db&lt;/code&gt; to find our socket, and
calls &lt;code&gt;recv&lt;/code&gt; on that socket.&lt;/p&gt;

&lt;p&gt;OK, let's check out
&lt;a href=&quot;https://github.com/erlang/otp/blob/master/lib/kernel/src/inet_db.erl#L783-L790&quot;&gt;&lt;code&gt;inet_db&lt;/code&gt;&lt;/a&gt;. Looks
like it retrieves module information stored via &lt;code&gt;erlang:set_port_data&lt;/code&gt;, &lt;a href=&quot;https://github.com/erlang/otp/blob/master/lib/kernel/src/inet_db.erl#L774-L778&quot;&gt;in the call above&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A grepping for a call to &lt;code&gt;inet_db:register_module&lt;/code&gt; reveals that multiple modules register themselves this way. Among these, we find one of particular interest.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lib/kernel/src/inet_tcp.erl
169:        inet_db:register_socket(S, ?MODULE),
177:        inet_db:register_socket(S, ?MODULE),
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let's see &lt;a href=&quot;https://github.com/erlang/otp/blob/master/lib/kernel/src/inet_tcp.erl#L75-L79&quot;&gt;how inet_tcp.erl implements recv&lt;/a&gt;. Hmm, just a pass-through to &lt;a href=&quot;https://github.com/erlang/otp/blob/master/erts/preloaded/src/prim_inet.erl#L675-L708&quot;&gt;&lt;code&gt;prim_inet&lt;/code&gt;&lt;/a&gt;. Let's look there.&lt;/p&gt;

&lt;p&gt;It seems here that our erlang call-chain bottoms out in a call to &lt;code&gt;ctl_cmd&lt;/code&gt;,
which is itself a wrapper to &lt;code&gt;erlang:port_control&lt;/code&gt;, sending control data over
into C-land. We'll need to look at out TCP port driver to figure out what comes
next.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    case ctl_cmd(S, ?TCP_REQ_RECV, [enc_time(Time), ?int32(Length)])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A slight hitch is finding the source code for this driver. Perhaps the marco
&lt;code&gt;?TCP_REQ_RECV&lt;/code&gt; can help us find what we're after?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$  rg 'TCP_REQ_RECV'
lib/kernel/src/inet_int.hrl
100:-define(TCP_REQ_RECV,           42).

erts/preloaded/src/prim_inet.erl
584:    case ctl_cmd(S, ?TCP_REQ_RECV, [enc_time(Time), ?int32(Length)]) of

erts/emulator/drivers/common/inet_drv.c
735:#define TCP_REQ_RECV           42
10081:    case TCP_REQ_RECV: {
10112:  if (enq_async(INETP(desc), tbuf, TCP_REQ_RECV) &amp;lt; 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A-ha! &lt;a href=&quot;https://github.com/erlang/otp/blob/master/erts/emulator/drivers/common/inet_drv.c#L10200-L10249&quot;&gt;&lt;code&gt;inet_drv.c&lt;/code&gt;&lt;/a&gt;, here we come!&lt;/p&gt;

&lt;p&gt;Indeed, this C function here, responsible for the actual call to &lt;code&gt;sock_select&lt;/code&gt;,
will proactively reject recv calls where the requested payload size &lt;code&gt;n&lt;/code&gt; is bigger than
&lt;code&gt;TCP_MAX_PACKET_SIZE&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (n &amp;gt; TCP_MAX_PACKET_SIZE)
    return ctl_error(ENOMEM, rbuf, rsize);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and &lt;code&gt;TCP_MAX_PACKET_SIZE&lt;/code&gt; itself is &lt;a href=&quot;https://github.com/erlang/otp/blob/master/erts/emulator/drivers/common/inet_drv.c#L1143&quot;&gt;defined in the same source file&lt;/a&gt; as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define TCP_MAX_PACKET_SIZE 0x4000000 /* 64 M */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;thereby explaining our weird ENOMEM error.&lt;/p&gt;

&lt;p&gt;Now, how to solve this conundrum? A possible approach would be to maintain some
state in our receiver, optimistically read as much data as possible, and then
try to reconstruct the logical messages, perhaps using something like
&lt;a href=&quot;http://erlang.org/doc/man/erlang.html#ghlink-decode_packet-3-id291848&quot;&gt;erlang:decode_packet&lt;/a&gt;
to take care of the book-keeping for us.&lt;/p&gt;

&lt;h2&gt;Taking a step back — and finding a clean solution&lt;/h2&gt;

&lt;p&gt;Before we jump to writing more code, let's consider our position. We're trying
to read a framed message off of a TCP stream. It's been done thousands of
times before. Surely the sagely developers whose combined experience is encoded
in OTP have thought of an elegant solution to this problem?&lt;/p&gt;

&lt;p&gt;It turns out that if you read the &lt;a href=&quot;https://erldocs.com/current/kernel/inet.html?i=0&amp;amp;search=inet:seto#setopts/2&quot;&gt;very long man entry for
inet:setopts&lt;/a&gt;,
you'll eventually come across this revealing paragraph:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;{packet, PacketType}(TCP/IP sockets)&lt;/p&gt;

&lt;p&gt;Defines the type of packets to use for a socket. Possible values:&lt;/p&gt;

&lt;p&gt;raw | 0&lt;/p&gt;

&lt;p&gt;No packaging is done.&lt;/p&gt;

&lt;p&gt;1 | 2 | 4&lt;/p&gt;

&lt;p&gt;Packets consist of a header specifying the number of bytes in the packet, followed by that number of bytes. The header length can be one, two, or four bytes, and containing an unsigned integer in big-endian byte order. Each send operation generates the header, and the header is stripped off on each receive operation.&lt;/p&gt;

&lt;p&gt;The 4-byte header is limited to 2Gb.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Packets consist of a header specifying the number of bytes in the packet, followed by that number of bytes.&lt;/em&gt;&lt;/strong&gt; Yes indeed they do! Let's try it out!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env escript
recv(Sock) -&amp;gt;
  {ok, String} = gen_tcp:recv(Sock,0),
  io:format(&quot;Got string of length: ~p~n&quot;, [byte_size(String)]),
  recv(Sock).

main(_) -&amp;gt;
  {ok, L} = gen_tcp:listen(7777, [binary, {active, false}, {reuseaddr, true}, {packet, 4}]),
  {ok, Sock} = gen_tcp:accept(L),
  recv(Sock).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the output is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Got string of length: 1000
Got string of length: 1000000
Got string of length: 10000000
Got string of length: 100000000
escript: exception error: no match of right hand side value {error,closed}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Problem solved! (The last error is from a &lt;code&gt;recv&lt;/code&gt; call on the socket after it
has been closed from the Python side). Turns out that our TCP framing pattern
is in fact so common, it's been subsumed by OTP as a mere &lt;em&gt;option&lt;/em&gt; for gen_tcp
sockets!&lt;/p&gt;

&lt;p&gt;If you'd like to know why setting this option lets us sidestep the
&lt;code&gt;TCP_MAX_PACKET_SIZE&lt;/code&gt; check, I encourage you to take a dive into the OTP
codebase and find out. It's suprisingly easy to navigate, and full of great
code.&lt;/p&gt;

&lt;p&gt;And if you ever find yourself fighting a networking problem using brute-force
in Erlang, please consider the question: &quot;Peraphs this was solved long ago and
the solution lives in OTP?&quot; Chances are, the answer is yes!&lt;/p&gt;

	</description>
        <pubDate>Mon, 18 Feb 2019 00:00:00 +0100</pubDate>
        <link>http://pzel.github.io/2019/02/18/Figuring-out-a-gen_tcp-recv_limitation.html</link>
        <guid isPermaLink="true">http://pzel.github.io/2019/02/18/Figuring-out-a-gen_tcp-recv_limitation.html</guid>
      </item>
    
      <item>
        <title>Sending 0.0.0.0 doesn't make sense</title>
        <description>
	&lt;p&gt;While I've grown used to specifying
&lt;a href=&quot;https://en.wikipedia.org/wiki/0.0.0.0&quot;&gt;0.0.0.0&lt;/a&gt; as the listening address for
servers, I got bitten yesterday and realized the dangers of this practice.&lt;/p&gt;

&lt;p&gt;If the listening address of a server ever needs to be communicated to others
(as is the case with clustered systems), configuring &lt;code&gt;0.0.0.0&lt;/code&gt; will lead to bad
things happening. That is: other servers, having learned that your address is
&lt;code&gt;0.0.0.0:SOMEPORT&lt;/code&gt;, will attempt to connect and fail.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://tools.ietf.org/html/rfc1122&quot;&gt;RFC&lt;/a&gt; states clearly:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;This host on this network.  MUST NOT be sent, except as
a source address as part of an initializatioan procedure
by which the host learns its own IP address.&lt;/p&gt;&lt;/blockquote&gt;

	</description>
        <pubDate>Sat, 21 Jul 2018 00:00:00 +0200</pubDate>
        <link>http://pzel.github.io/til/2018/07/21/sending-0000-doesnt-make-sense.html</link>
        <guid isPermaLink="true">http://pzel.github.io/til/2018/07/21/sending-0000-doesnt-make-sense.html</guid>
      </item>
    
      <item>
        <title>CUPS: Adding a printer as a user</title>
        <description>
	&lt;p&gt;If you're getting strange &lt;code&gt;Forbidden&lt;/code&gt; errors while adding new printers via CUPS,
make sure your user is part of the &lt;code&gt;lpadmin&lt;/code&gt; group.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gpasswd -a $USER lpadmin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Log out, log in again and enjoy your printer.&lt;/p&gt;

	</description>
        <pubDate>Tue, 27 Mar 2018 00:00:00 +0200</pubDate>
        <link>http://pzel.github.io/til/2018/03/27/CUPS-adding-printer-as-a-user.html</link>
        <guid isPermaLink="true">http://pzel.github.io/til/2018/03/27/CUPS-adding-printer-as-a-user.html</guid>
      </item>
    
  </channel>
</rss>
