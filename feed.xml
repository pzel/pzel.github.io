<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Simon Zelazny's Blog</title>
    <description></description>
    <link>http://pzel.github.io</link>
    <atom:link href="http://pzel.github.io/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Uncrashable languages aren't</title>
        <description>A trivial observation, with some examples
	&lt;h2&gt;Making buggy situations unrepresentable&lt;/h2&gt;

&lt;p&gt;Programs have &lt;strong&gt;bugs&lt;/strong&gt;. Both creators and end-users of software dislike
bugs. Businesses paying for software development dislike bugs. It's no wonder
that, as the role of software in the world expands, we've become very
interested in minimizing occurrences of bugs.&lt;/p&gt;

&lt;p&gt;One way of reducing bugs is via process: making sure that critical code is
tested to the greatest practical extent. Another way is via construction:
making sure that buggy code is not representable. This could be achieved by
making such code unexpressible in the syntax of a language, or having it fail
the compiler's type check.&lt;/p&gt;

&lt;p&gt;There are two new programming languages that take a principled stance on the
side of &lt;em&gt;non-representability&lt;/em&gt;, by preventing code from crashing wantonly:
&lt;a href=&quot;https://elm-lang.org/&quot;&gt;Elm&lt;/a&gt; and &lt;a href=&quot;https://www.ponylang.io/&quot;&gt;Pony&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Elm does this by eliminating exceptions from language semantics and forcing the
programmer to handle all branches of sum types (i.e your code has to cover all
representable states that it might encounter).&lt;/p&gt;

&lt;p&gt;Pony does this by allowing anonymous exceptions (the &lt;code&gt;error&lt;/code&gt; operator), but
forcing the programmer to deal with them at some point. All functions – apart
from those which are explicitly marked as capable of throwing errors – &lt;em&gt;MUST&lt;/em&gt;
be total and always return a value.&lt;/p&gt;

&lt;h2&gt;A small aside about division by zero&lt;/h2&gt;

&lt;p&gt;Elm used to crash when you tried to divide by zero. Now (I tried version
&lt;code&gt;0.19&lt;/code&gt;), it returns &lt;code&gt;0&lt;/code&gt; for integer division and &lt;code&gt;Infinity&lt;/code&gt; for floating-point
division. The division functions are therefore total.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; 5.0 / 0.0
Infinity : Float
&amp;gt; 5 // 0
0 : Int
&amp;gt; remainderBy 5 0
0 : Int
&amp;gt; modBy 5 0
0 : Int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pony also returns zero when zero is the divisor.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;actor Main                                        //  This code prints:
  new create(env: Env) =&amp;gt;                         //  0
   env.out.print((U32(1) / U32(0)).string())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, Pony also provides &lt;a href=&quot;https://tutorial.ponylang.io/expressions/arithmetic.html&quot;&gt;partial
arithmetic&lt;/a&gt; operators
(&lt;code&gt;/?&lt;/code&gt; for division, &lt;code&gt;+?&lt;/code&gt; for addition, below), for when you explicitly need
integer over/underflows and division-by-zero to be illegal:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;actor Main                                         //  This code prints:
  new create(env: Env) =&amp;gt;                          //  div by zero
    try U32(1) /? U32(0)                           //  overflow
    else env.out.print(&quot;div by zero&quot;)              //  0
    end                                            //  0
    try U8(255) +? U8(1)
    else env.out.print(&quot;overflow&quot;)
    end
   env.out.print((U32(1) / U32(0)).string())
   env.out.print((U8(255) + U8(1)).string())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While returning '0' for divison-by-zero is a controversial topic (yet silent
integer overflows somehow don't generate the same debate), I think it's
reasonable to view this compromise as the necessary cost of eliminating crashes
in our code. More interesting is this: we have just made a
tradeoff between eliminating &lt;strong&gt;crashes&lt;/strong&gt; and &lt;strong&gt;wrong results&lt;/strong&gt;. Having a total
division function eliminates crashes at the cost of allowing wrong results to
propagate. Let's dig into this a bit more.&lt;/p&gt;

&lt;h2&gt;Bugs and the bottom type&lt;/h2&gt;

&lt;p&gt;Taxonomy is supposed to be the lowest form of science, but let's indulge and
distinguish two main types of program misbehavior:&lt;/p&gt;

&lt;p&gt;   1) A program (or function) produces output which does not match the
   programmer's intent, design, or specification;&lt;/p&gt;

&lt;p&gt;   2) A program (or function) fails to produce output (e.g. freezes or crashes)&lt;/p&gt;

&lt;p&gt;I hope you'll agree that eliminating 'bugs' caused by the first type of error
is not an easy feat, and probably not within the scope of a language runtime or
compiler. Carefully designing your data structures to make illegal states
unrepresentable may go a long way towards eliminating failures of this kind, as
will a good testing regimen. Let's not delve deeper into this category and
focus on the second one: &lt;strong&gt;functions that crash and never return&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;The wikipedia article on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bottom_type&quot;&gt;Bottom
Type&lt;/a&gt; makes for an intersting
read. It's nice to conceive of &lt;code&gt;⊥&lt;/code&gt; as a hole in the program, where execution
stops and meaning collapses. Since the bottom type is a subtype of every type,
theoretically any function can return the 'bottom value' — although returning
the 'bottom value' acutally means &lt;em&gt;never returning at all&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;My claim is that while some languages, like Haskell or Rust, might explicitly
embrace the existence of &lt;code&gt;⊥&lt;/code&gt;, languages that prevent programmers from
'invoking' the bottom type will always contain inconsistencies (I'm leaving
dependently-typed languages out of this). Below are two examples.&lt;/p&gt;

&lt;h2&gt;Broken promises and infinite loops&lt;/h2&gt;

&lt;p&gt;Elm's promise is that an application written in Elm will never crash, unless
there is a bug in the Elm runtime. &lt;a href=&quot;https://medium.com/@eeue56/top-6-ways-to-make-your-elm-app-crash-at-runtime-562b2fa92d70&quot;&gt;There are articles out
there&lt;/a&gt;
that enumerate the various broken edge-cases (regexp, arrays, json decoding),
but these cases can arguably be construed as bugs in the runtime or mistakes in
library API design. That is, these bugs do not mean that Elm's promise is for
naught.&lt;/p&gt;

&lt;p&gt;However, if you think about it, an infinite loop is a manifestation of the
bottom type just as much as an outright crash, and such a loop is possible in
all Turing-complete languages.&lt;/p&gt;

&lt;p&gt;Here's a legal Elm app that freezes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Browser
import Html exposing (Html, button, div, text)
import Html.Events exposing (onClick)

main =
  Browser.sandbox { init = 0, update = update, view = view }

type Msg = Increment | Decrement

add : Int -&amp;gt; Int
add n =
  add (n+1)

update msg model =
  case msg of
    Increment -&amp;gt;
      add model

    Decrement -&amp;gt;
      model - 1

view model =
  div []
    [ button [ onClick Decrement ] [ text &quot;-&quot; ]
    , div [] [ text (String.fromInt model) ]
    , button [ onClick Increment ] [ text &quot;+&quot; ]
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What will happen when you click the &lt;code&gt;+&lt;/code&gt; button in the browser? This is what:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/bad-elm.png&quot; alt=&quot;Screenshot of browser message saying: 'A web page is slowing down your browser.'&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The loop is hidden in the &lt;code&gt;add&lt;/code&gt; function, which never returns an &lt;code&gt;Int&lt;/code&gt;. Its
true return type, in this program, is precisely &lt;code&gt;⊥&lt;/code&gt;. Without explicitly
crashing-and-stopping, we've achieved the logical (and type-systematic)
equivalent: a freeze.&lt;/p&gt;

&lt;h2&gt;Galloping forever and ever&lt;/h2&gt;

&lt;p&gt;The Pony language is susceptible to a similar trick, but we'll have to be a bit
more crafty. First of all, Pony does indeed allow the programmer to 'invoke'
the Bottom Type, by simply using the keyword &lt;code&gt;error&lt;/code&gt; anywhere in a function
body. Using this keyword (or calling a partial function) means that we, the
programmer, now have a choice to make:&lt;/p&gt;

&lt;p&gt;  1) Use &lt;code&gt;try/else&lt;/code&gt; to handle the possibility of error, and return a sensible
  default value&lt;/p&gt;

&lt;p&gt;  2) Mark this function as partial &lt;code&gt;?&lt;/code&gt;, and force callers to deal with the
  possibility of the Bottom Type rearing its head.&lt;/p&gt;

&lt;p&gt;However, we can craft a function that spins endlessly, never exiting, and thus
'returning' the Bottom Type, without the compiler complaining, and without
having to annotate it as partial.&lt;/p&gt;

&lt;p&gt;Interestingly enough, naïve approaches are optimized away by the compiler,
producing surprising result values instead of spinning forever:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;actor Main
  new create(env: Env) =&amp;gt;
    let x = spin(false)
    env.out.print(x.string())

  fun spin(n: Bool): Bool =&amp;gt;
    spin(not n)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before you run this program, think about what, if anything, it should
output. Then, run it and see. Seems like magic to me, but I'm guessing this is
LLVM detecting the oscillation and producing a 'sensible' value.&lt;/p&gt;

&lt;p&gt;We can outsmart the optimizer by farming out the loop to another object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;actor Main
  new create(env: Env) =&amp;gt;
    let t: TarpitTrap = TarpitTrap
    let result = t.spin(true)
    env.out.print(result.string())

class TarpitTrap
  fun spin(n: Bool): Bool =&amp;gt;
    if n then spin(not n)
    else spin(n)
    end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, this program properly freezes forever, as intended. Of course this is just
a contrived demonstration, but one can imagine an analogous situation happening
at run-time, for example when parsing tricky (or malicious) input data.&lt;/p&gt;

&lt;h2&gt;The snake in the garden&lt;/h2&gt;

&lt;p&gt;While I enjoy working both in Elm and Pony, I'm not a particular fan of these
languages' hard-line stance on making sure programs never crash. As long as
infinite loops are expressible in the language, the Bottom Type cannot be
excised.&lt;/p&gt;

&lt;p&gt;Even without concerns somewhat external to our programming language runtime,
such as memory constraints, FFIs, syscalls, or the proverbial admin pulling the
plug on our machine (did this really used to happen?), the humble infinite loop
ensures that non-termination can never be purged from our
(non-dependently-typed) program.&lt;/p&gt;

&lt;p&gt;Instead of focusing on preventing crashes in the small, I think we, as
programmers, should embrace failure and look at how to deal with error from a
higher-level perspective, looking at processes, machines, and entire
systems. Erlang and OTP got this right so many years ago. Ensuring the proper
operation of a system &lt;em&gt;despite&lt;/em&gt; failure is a much more practical goal than
vainly trying to expel the infinitely-looping snake from our software garden.&lt;/p&gt;

	</description>
        <pubDate>Sun, 31 Mar 2019 00:00:00 +0100</pubDate>
        <link>http://pzel.github.io/2019/03/31/Uncrashable-languages-arent.html</link>
        <guid isPermaLink="true">http://pzel.github.io/2019/03/31/Uncrashable-languages-arent.html</guid>
      </item>
    
      <item>
        <title>How to grab all hosts but the first, in Ansible</title>
        <description>
	&lt;p&gt;Today I was trying to figure out how to run a particular ansible play on one
host out of a group, and another play on &lt;em&gt;all the other hosts&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The answer was found in a &lt;a href=&quot;https://grokbase.com/t/gg/ansible-project/14bkjnvrnq/how-to-define-all-hosts-but-first-in-a-group&quot;&gt;mailing group posting from 2014&lt;/a&gt;, but in case
that service goes down, here's my note-to-self on how to do it.&lt;/p&gt;

&lt;p&gt;Let's say you have a group of hosts called &lt;code&gt;stateful_cluster_hosts&lt;/code&gt; in your
inventory.  You'd like to upload &lt;code&gt;files/leader_script.sh.j2&lt;/code&gt; to the first host,
and &lt;code&gt;files/follower_script.sh.j2&lt;/code&gt; to all the others.&lt;/p&gt;

&lt;p&gt;The play for the &lt;strong&gt;leader host&lt;/strong&gt; would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- hosts: stateful_cluster_hosts[0]
  tasks:
  - name: &quot;Upload leader start script&quot;
    template:
      src: files/leader_script.sh.j2
      dest: start.sh
      mode: &quot;u=rwx,g=rx,o=rx&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The play for the &lt;strong&gt;follower hosts&lt;/strong&gt; would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- hosts:  stateful_cluster_hosts:!stateful_cluster_hosts[0]
  tasks:
  - name: &quot;Upload follower start script&quot;
    template:
      src: files/follower_script.sh.j2
      dest: start.sh
      mode: &quot;u=rwx,g=rx,o=rx&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where the sytax &lt;code&gt;list:!list[idx]&lt;/code&gt; means &lt;em&gt;take &lt;code&gt;list&lt;/code&gt;, but filter out
&lt;code&gt;list[idx]&lt;/code&gt;&lt;/em&gt;.&lt;/p&gt;

	</description>
        <pubDate>Wed, 20 Mar 2019 00:00:00 +0100</pubDate>
        <link>http://pzel.github.io/til/2019/03/20/How-to-grab-all-hosts-but-the-first-in-Ansible.html</link>
        <guid isPermaLink="true">http://pzel.github.io/til/2019/03/20/How-to-grab-all-hosts-but-the-first-in-Ansible.html</guid>
      </item>
    
      <item>
        <title>Figuring out a gen_tcp:recv limitation</title>
        <description>In which a suprisingly pernicious framed payload leads to OTP spelunking.
	&lt;h2&gt;The setup: sending a string over TCP&lt;/h2&gt;

&lt;p&gt;Let's say you want to send the ASCII string &lt;code&gt;Fiat lux!&lt;/code&gt; to an Erlang process
listening on the other side of a TCP connection. Not a big deal, right?&lt;/p&gt;

&lt;p&gt;Our sending application is written in Python. Here's what it might look like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#!/usr/bin/env python3
import socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((&quot;127.0.0.1&quot;, 7777))
data_to_send = b&quot;Fiat Lux!&quot;
sock.sendall(data_to_send)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;... and here's the receiving Erlang application:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;erlang&quot;&gt;#!/usr/bin/env escript
main(_) -&amp;gt;
  {ok, L} = gen_tcp:listen(7777, [binary, {active, false}, {reuseaddr, true}]),
  {ok, Sock} = gen_tcp:accept(L),
  {ok, String} = gen_tcp:recv(Sock, 0),
  io:format(&quot;Got string: ~ts~n&quot;, [String]),
  erlang:halt(0).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we start the Erlang receiver (in shell 1), then run the Python sender (in
shell2), we should see the receiver emit the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;$ ./receive.escript
Got string: Fiat Lux!
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, we optimistically sent all our data over TCP from the Python
app, and received all that data, intact, on the other side. What's important
here is that our Erlang socket is in &lt;a href=&quot;http://erlang.org/doc/man/inet.html#ghlink-setopts-2-id215039&quot;&gt;passive
mode&lt;/a&gt;, which
means that incoming TCP data needs to be &lt;code&gt;recv&lt;/code&gt;'d off of the socket. The second
argument in &lt;code&gt;gen_tcp:recv(Sock, 0)&lt;/code&gt; means that we want to read however many
bytes are available to be read from the OS's network stack. In this case all
our data was kindly provided to us in one nice chunk.&lt;/p&gt;

&lt;p&gt;Success! Our real production application will be dealing with much bigger
pieces of data, so it behooves us to test with a larger payload. Let's try a
thousand characters.&lt;/p&gt;

&lt;h2&gt;More data&lt;/h2&gt;

&lt;p&gt;We update the sender and receiver as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#!/usr/bin/env python3
import socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((&quot;127.0.0.1&quot;, 7777))
data_to_send = b'a' * 1000
sock.sendall(data_to_send)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;erlang&quot;&gt;#!/usr/bin/env escript
main(_) -&amp;gt;
  {ok, L} = gen_tcp:listen(7777, [binary, {active, false}, {reusaddr, true}]),
  {ok, Sock} = gen_tcp:accept(L),
  {ok, String} = gen_tcp:recv(Sock, 0),
  io:format(&quot;Got string of length: ~p~n&quot;, [byte_size(String)]),
  erlang:halt(0).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we run our experiment, we see that our Erlang process does indeed get all
&lt;code&gt;1000&lt;/code&gt; bytes. Let's add one more zero to the payload.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#!/usr/bin/env python3
import socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((&quot;127.0.0.1&quot;, 7777))
data_to_send = b'a' * 10000
sock.sendall(data_to_send)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we hit our first snag!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Got string of length: 1460
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aha! Our &lt;code&gt;gen_tcp:recv(Sock, 0)&lt;/code&gt; call asked the OS to give us whatever bytes it
had ready in the TCP buffer, and so that's what we received. TCP is a streaming
protocol, and there is no guarantee that a given sequence of bytes received on
the socket will correspond to a logical message in our application layer. The
low-effort way of handling this issue is by prefixing every logical message on
the TCP socket with a known-width integer, representing the length of the
message in bytes. &quot;Low-effort&quot; sounds like the kind of thing you put in place
when the deadline was yesterday. Onward!&lt;/p&gt;

&lt;p&gt;Let's take our initial string as an example. Instead of sending the following
sequence of &lt;code&gt;9&lt;/code&gt; bytes on the wire:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ascii:     F    i   a    t   ␣    l    u    x   !

Binary:   70  105  97  116  32  108  117  120  33
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We'd first prefix it with an 32-bit integer representing its size in bytes, and
then append the binary, giving &lt;code&gt;13&lt;/code&gt; bytes in total.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ascii:     ␀   ␀  ␀   ␉  F    i   a    t   ␣    l    u    x   !

Binary:    0   0   0   9  70  105  97  116  32  108  117  120  33
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, the first 4 bytes that reach our receiver can be interpreted as the length
of the next logical message. We can use this number to tell &lt;code&gt;gen_tcp:recv&lt;/code&gt; how
many bytes we want to read from the socket.&lt;/p&gt;

&lt;p&gt;To encode an integer into 32 bits, we'll use &lt;a href=&quot;[https://docs.python.org/3/library/struct.html&quot;&gt;Python's struct module&lt;/a&gt;. &lt;code&gt;struct.pack(&quot;&amp;gt;I&quot;, 9)&lt;/code&gt; will do
exactly what we want: encode a 32-bit unsigned Integer (&lt;code&gt;9&lt;/code&gt;, in this case) in
Big-endian (or network) order.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#!/usr/bin/env python3
import socket
import struct
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((&quot;127.0.0.1&quot;, 7777))
data_to_send = b'a' * 10000
header = struct.pack(&quot;&amp;gt;I&quot;, len(data_to_send))
sock.sendall(header + data_to_send)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the decoding side, we'll break up the receiving into two parts:&lt;/p&gt;

&lt;p&gt;1) Read 4 bytes from the socket, interpret these as &lt;code&gt;Header&lt;/code&gt;, a 32-bit unsigned
int.&lt;/p&gt;

&lt;p&gt;2) Read &lt;code&gt;Header&lt;/code&gt; bytes off the socket. The receiving Erlang process will
'block' until that much data is read (or until the other side disconnects). The
received bytes constitute a logical message.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env escript
main(_) -&amp;gt;
  {ok, L} = gen_tcp:listen(7777, [binary, {active, false}, {reuseaddr, true}]),
  {ok, Sock} = gen_tcp:accept(L),
  {ok, &amp;lt;&amp;lt;Header:32&amp;gt;&amp;gt;} = gen_tcp:recv(Sock, 4),
  io:format(&quot;Got header: ~p~n&quot;, [Header]),
  {ok, String} = gen_tcp:recv(Sock, Header),
  io:format(&quot;Got string of length: ~p~n&quot;, [byte_size(String)]),
  erlang:halt(0).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we run our scripts, we'll see the Erlang receiver print the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Got header: 10000
Got string of length: 10000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Success! But apparently, our application needs to handle messages much bigger
than 10 kilobytes. Let's see how far we can take this approach.&lt;/p&gt;

&lt;h2&gt;Yet more data&lt;/h2&gt;

&lt;p&gt;Can we do a megabyte? Ten? A hundred? Let's find out, using the following loop
for the sender:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#!/usr/bin/env python3
import socket
import struct
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((&quot;127.0.0.1&quot;, 7777))
for l in [1000, 1000*1000, 10*1000*1000, 100*1000*1000]:
    data_to_send = b'a' * l
    header = struct.pack(&quot;&amp;gt;I&quot;, len(data_to_send))
    sock.sendall(header + data_to_send)
sock.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;...and a recursive receive function for the receiver:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;erlang&quot;&gt;#!/usr/bin/env escript
recv(Sock) -&amp;gt;
  {ok, &amp;lt;&amp;lt;Header:32&amp;gt;&amp;gt;} = gen_tcp:recv(Sock, 4),
  io:format(&quot;Got header: ~p~n&quot;, [Header]),
  {ok, String} = gen_tcp:recv(Sock, Header),
  io:format(&quot;Got string of length: ~p~n&quot;, [byte_size(String)]),
  recv(Sock).

main(_) -&amp;gt;
  {ok, L} = gen_tcp:listen(7777, [binary, {active, false}, {reuseaddr, true}]),
  {ok, Sock} = gen_tcp:accept(L),
  recv(Sock).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running this will lead to our Erlang process crashing with an interesting message:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Got header: 1000
Got string of length: 1000
Got header: 1000000
Got string of length: 1000000
Got header: 10000000
Got string of length: 10000000
Got header: 100000000
escript: exception error: no match of right hand side value {error,enomem}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;enomem&lt;/code&gt; looks like a strange kind of error indeed. It happens when we get the
100-megabyte header and attempt to read that data off the socket. Let's go spelunking to find out where this error is coming from.&lt;/p&gt;

&lt;h2&gt;Spelunking for &lt;code&gt;{error, enomem}&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;First, let's take a look at &lt;a href=&quot;https://github.com/erlang/otp/blob/master/lib/kernel/src/gen_tcp.erl#L302-L308&quot;&gt;what &lt;code&gt;gen_tcp:recv&lt;/code&gt;
does&lt;/a&gt;
with its arguments. It seems that it checks &lt;code&gt;inet_db&lt;/code&gt; to find our socket, and
calls &lt;code&gt;recv&lt;/code&gt; on that socket.&lt;/p&gt;

&lt;p&gt;OK, let's check out
&lt;a href=&quot;https://github.com/erlang/otp/blob/master/lib/kernel/src/inet_db.erl#L783-L790&quot;&gt;&lt;code&gt;inet_db&lt;/code&gt;&lt;/a&gt;. Looks
like it retrieves module information stored via &lt;code&gt;erlang:set_port_data&lt;/code&gt;, &lt;a href=&quot;https://github.com/erlang/otp/blob/master/lib/kernel/src/inet_db.erl#L774-L778&quot;&gt;in the call above&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A grepping for a call to &lt;code&gt;inet_db:register_module&lt;/code&gt; reveals that multiple modules register themselves this way. Among these, we find one of particular interest.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lib/kernel/src/inet_tcp.erl
169:        inet_db:register_socket(S, ?MODULE),
177:        inet_db:register_socket(S, ?MODULE),
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let's see &lt;a href=&quot;https://github.com/erlang/otp/blob/master/lib/kernel/src/inet_tcp.erl#L75-L79&quot;&gt;how inet_tcp.erl implements recv&lt;/a&gt;. Hmm, just a pass-through to &lt;a href=&quot;https://github.com/erlang/otp/blob/master/erts/preloaded/src/prim_inet.erl#L675-L708&quot;&gt;&lt;code&gt;prim_inet&lt;/code&gt;&lt;/a&gt;. Let's look there.&lt;/p&gt;

&lt;p&gt;It seems here that our erlang call-chain bottoms out in a call to &lt;code&gt;ctl_cmd&lt;/code&gt;,
which is itself a wrapper to &lt;code&gt;erlang:port_control&lt;/code&gt;, sending control data over
into C-land. We'll need to look at out TCP port driver to figure out what comes
next.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    case ctl_cmd(S, ?TCP_REQ_RECV, [enc_time(Time), ?int32(Length)])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A slight hitch is finding the source code for this driver. Perhaps the marco
&lt;code&gt;?TCP_REQ_RECV&lt;/code&gt; can help us find what we're after?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$  rg 'TCP_REQ_RECV'
lib/kernel/src/inet_int.hrl
100:-define(TCP_REQ_RECV,           42).

erts/preloaded/src/prim_inet.erl
584:    case ctl_cmd(S, ?TCP_REQ_RECV, [enc_time(Time), ?int32(Length)]) of

erts/emulator/drivers/common/inet_drv.c
735:#define TCP_REQ_RECV           42
10081:    case TCP_REQ_RECV: {
10112:  if (enq_async(INETP(desc), tbuf, TCP_REQ_RECV) &amp;lt; 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A-ha! &lt;a href=&quot;https://github.com/erlang/otp/blob/master/erts/emulator/drivers/common/inet_drv.c#L10200-L10249&quot;&gt;&lt;code&gt;inet_drv.c&lt;/code&gt;&lt;/a&gt;, here we come!&lt;/p&gt;

&lt;p&gt;Indeed, this C function here, responsible for the actual call to &lt;code&gt;sock_select&lt;/code&gt;,
will proactively reject recv calls where the requested payload size &lt;code&gt;n&lt;/code&gt; is bigger than
&lt;code&gt;TCP_MAX_PACKET_SIZE&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (n &amp;gt; TCP_MAX_PACKET_SIZE)
    return ctl_error(ENOMEM, rbuf, rsize);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and &lt;code&gt;TCP_MAX_PACKET_SIZE&lt;/code&gt; itself is &lt;a href=&quot;https://github.com/erlang/otp/blob/master/erts/emulator/drivers/common/inet_drv.c#L1143&quot;&gt;defined in the same source file&lt;/a&gt; as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define TCP_MAX_PACKET_SIZE 0x4000000 /* 64 M */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;thereby explaining our weird ENOMEM error.&lt;/p&gt;

&lt;p&gt;Now, how to solve this conundrum? A possible approach would be to maintain some
state in our receiver, optimistically read as much data as possible, and then
try to reconstruct the logical messages, perhaps using something like
&lt;a href=&quot;http://erlang.org/doc/man/erlang.html#ghlink-decode_packet-3-id291848&quot;&gt;erlang:decode_packet&lt;/a&gt;
to take care of the book-keeping for us.&lt;/p&gt;

&lt;h2&gt;Taking a step back — and finding a clean solution&lt;/h2&gt;

&lt;p&gt;Before we jump to writing more code, let's consider our position. We're trying
to read a framed message off of a TCP stream. It's been done thousands of
times before. Surely the sagely developers whose combined experience is encoded
in OTP have thought of an elegant solution to this problem?&lt;/p&gt;

&lt;p&gt;It turns out that if you read the &lt;a href=&quot;https://erldocs.com/current/kernel/inet.html?i=0&amp;amp;search=inet:seto#setopts/2&quot;&gt;very long man entry for
inet:setopts&lt;/a&gt;,
you'll eventually come across this revealing paragraph:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;{packet, PacketType}(TCP/IP sockets)&lt;/p&gt;

&lt;p&gt;Defines the type of packets to use for a socket. Possible values:&lt;/p&gt;

&lt;p&gt;raw | 0&lt;/p&gt;

&lt;p&gt;No packaging is done.&lt;/p&gt;

&lt;p&gt;1 | 2 | 4&lt;/p&gt;

&lt;p&gt;Packets consist of a header specifying the number of bytes in the packet, followed by that number of bytes. The header length can be one, two, or four bytes, and containing an unsigned integer in big-endian byte order. Each send operation generates the header, and the header is stripped off on each receive operation.&lt;/p&gt;

&lt;p&gt;The 4-byte header is limited to 2Gb.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Packets consist of a header specifying the number of bytes in the packet, followed by that number of bytes.&lt;/em&gt;&lt;/strong&gt; Yes indeed they do! Let's try it out!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env escript
recv(Sock) -&amp;gt;
  {ok, String} = gen_tcp:recv(Sock,0),
  io:format(&quot;Got string of length: ~p~n&quot;, [byte_size(String)]),
  recv(Sock).

main(_) -&amp;gt;
  {ok, L} = gen_tcp:listen(7777, [binary, {active, false}, {reuseaddr, true}, {packet, 4}]),
  {ok, Sock} = gen_tcp:accept(L),
  recv(Sock).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the output is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Got string of length: 1000
Got string of length: 1000000
Got string of length: 10000000
Got string of length: 100000000
escript: exception error: no match of right hand side value {error,closed}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Problem solved! (The last error is from a &lt;code&gt;recv&lt;/code&gt; call on the socket after it
has been closed from the Python side). Turns out that our TCP framing pattern
is in fact so common, it's been subsumed by OTP as a mere &lt;em&gt;option&lt;/em&gt; for gen_tcp
sockets!&lt;/p&gt;

&lt;p&gt;If you'd like to know why setting this option lets us sidestep the
&lt;code&gt;TCP_MAX_PACKET_SIZE&lt;/code&gt; check, I encourage you to take a dive into the OTP
codebase and find out. It's suprisingly easy to navigate, and full of great
code.&lt;/p&gt;

&lt;p&gt;And if you ever find yourself fighting a networking problem using brute-force
in Erlang, please consider the question: &quot;Peraphs this was solved long ago and
the solution lives in OTP?&quot; Chances are, the answer is yes!&lt;/p&gt;

	</description>
        <pubDate>Mon, 18 Feb 2019 00:00:00 +0100</pubDate>
        <link>http://pzel.github.io/2019/02/18/Figuring-out-a-gen_tcp-recv_limitation.html</link>
        <guid isPermaLink="true">http://pzel.github.io/2019/02/18/Figuring-out-a-gen_tcp-recv_limitation.html</guid>
      </item>
    
      <item>
        <title>Sending 0.0.0.0 doesn't make sense</title>
        <description>
	&lt;p&gt;While I've grown used to specifying
&lt;a href=&quot;https://en.wikipedia.org/wiki/0.0.0.0&quot;&gt;0.0.0.0&lt;/a&gt; as the listening address for
servers, I got bitten yesterday and realized the dangers of this practice.&lt;/p&gt;

&lt;p&gt;If the listening address of a server ever needs to be communicated to others
(as is the case with clustered systems), configuring &lt;code&gt;0.0.0.0&lt;/code&gt; will lead to bad
things happening. That is: other servers, having learned that your address is
&lt;code&gt;0.0.0.0:SOMEPORT&lt;/code&gt;, will attempt to connect and fail.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://tools.ietf.org/html/rfc1122&quot;&gt;RFC&lt;/a&gt; states clearly:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;This host on this network.  MUST NOT be sent, except as
a source address as part of an initializatioan procedure
by which the host learns its own IP address.&lt;/p&gt;&lt;/blockquote&gt;

	</description>
        <pubDate>Sat, 21 Jul 2018 00:00:00 +0200</pubDate>
        <link>http://pzel.github.io/til/2018/07/21/sending-0000-doesnt-make-sense.html</link>
        <guid isPermaLink="true">http://pzel.github.io/til/2018/07/21/sending-0000-doesnt-make-sense.html</guid>
      </item>
    
      <item>
        <title>CUPS: Adding a printer as a user</title>
        <description>
	&lt;p&gt;If you're getting strange &lt;code&gt;Forbidden&lt;/code&gt; errors while adding new printers via CUPS,
make sure your user is part of the &lt;code&gt;lpadmin&lt;/code&gt; group.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gpasswd -a $USER lpadmin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Log out, log in again and enjoy your printer.&lt;/p&gt;

	</description>
        <pubDate>Tue, 27 Mar 2018 00:00:00 +0200</pubDate>
        <link>http://pzel.github.io/til/2018/03/27/CUPS-adding-printer-as-a-user.html</link>
        <guid isPermaLink="true">http://pzel.github.io/til/2018/03/27/CUPS-adding-printer-as-a-user.html</guid>
      </item>
    
      <item>
        <title>Is node/0 a pure function?</title>
        <description>Thinking about Erlang functions in Haskell types
	&lt;p&gt;I had a very interesting debate with a co-worker today.&lt;/p&gt;

&lt;p&gt;I'd pointed out that the following filter expression felt like it was doing
unnecessary &lt;code&gt;IO&lt;/code&gt;, in the Haskell sense:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Enum.filter(fn {pid, _} -&amp;gt; :erlang.node(pid) == node() end)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The argument was simply that &lt;code&gt;node/0&lt;/code&gt; was not a pure function, and using such a
function as a predicate to &lt;code&gt;Enum.filter/2&lt;/code&gt; felt somewhat inelegant.  It was an
off-hand comment, and I didn't think much about it, until the author of the
code in question challenged me on what it means for a function to be pure.&lt;/p&gt;

&lt;p&gt;The gist of the argument was: since &lt;code&gt;node()&lt;/code&gt; always returns the same thing
throughout the run of a program on a given instance of the BEAM, is that not
the same as purity, for all practical purposes?&lt;/p&gt;

&lt;p&gt;All my theoretical arguments (like how running the code on different machines
yields different results) seemed unconvincing to the colleague. His argument
about &lt;code&gt;node()&lt;/code&gt; being effectively a global constant in the context of the VM
seemed to suffice for him to treat it like a pure function.&lt;/p&gt;

&lt;p&gt;When theory fails (or the theorizer is not convincing enough), practice comes
to the rescue. Here is a code snippet which proves that &lt;code&gt;node()&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; pure,
because it implicity depends on the state of the &lt;code&gt;net_kernel&lt;/code&gt; application:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;erl -eval &quot;
{ok, _} = net_kernel:start(['hello@kitty', shortnames]),
erlang:display(node()),
net_kernel:stop(),
{ok, _} = net_kernel:start(['bye@kitty', shortnames]),
erlang:display(node()).
&quot; -s erlang halt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will output two different values for &lt;code&gt;node()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Eshell V8.3.5.3  (abort with ^G)
1&amp;gt; 'hello@kitty'
'bye@kitty'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This demonstrates that &lt;code&gt;node/0&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; a pure function, even in the
loose-but-practical sense of always returning the same value during one run of
a program.&lt;/p&gt;

&lt;p&gt;For comparison, the &lt;a href=&quot;https://hackage.haskell.org/package/hostname-1.0/docs/Network-HostName.html&quot;&gt;somewhat-analogous
function&lt;/a&gt;
in Haskell does indeed have the type &lt;code&gt;IO Hostname&lt;/code&gt;.&lt;/p&gt;

	</description>
        <pubDate>Wed, 21 Mar 2018 00:00:00 +0100</pubDate>
        <link>http://pzel.github.io/2018/03/21/Is-node0-a-pure-function.html</link>
        <guid isPermaLink="true">http://pzel.github.io/2018/03/21/Is-node0-a-pure-function.html</guid>
      </item>
    
      <item>
        <title>Elixir's System.cmd and '*' expansion</title>
        <description>
	&lt;p&gt;I recently tried to use Elixir's
&lt;a href=&quot;https://hexdocs.pm/elixir/System.html#cmd/3&quot;&gt;&lt;code&gt;System.cmd/2&lt;/code&gt;&lt;/a&gt; to clear some
on-disk state, as part of a test. Unfortunately, my tests started to fail for
unclear reasons, and closer inspection proved that the state was &lt;em&gt;not&lt;/em&gt; being
cleared.&lt;/p&gt;

&lt;p&gt;Here's the command I was using:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; {&quot;&quot;, 0} = System.cmd(&quot;rm&quot;, [&quot;-rf&quot;, &quot;/tmp/myapp.mymodule/*&quot;])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Had I read the manual page linked above, I'd have known that:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;wildcard expansion will not happen (unless Path.wildcard/2 is used explicitly)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;What ended up happening was that the &lt;code&gt;*&lt;/code&gt; was being passed verbatim to the &lt;code&gt;rm&lt;/code&gt;
command. Since no such file existed inside the directory, nothing was
actually deleted.&lt;/p&gt;

&lt;p&gt;I changed the invocation to simply delete the entire directory, avoiding
expansion:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; {&quot;&quot;, 0} = System.cmd(&quot;rm&quot;, [&quot;-rf&quot;, &quot;/tmp/myapp.mymodule&quot;])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The non-hacky solution is to use an &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#rm_rf/1&quot;&gt;appropriate
function&lt;/a&gt; from the &lt;code&gt;File&lt;/code&gt; module.&lt;/p&gt;

	</description>
        <pubDate>Tue, 20 Mar 2018 00:00:00 +0100</pubDate>
        <link>http://pzel.github.io/til/2018/03/20/Elixir-cmd-star-expansion.html</link>
        <guid isPermaLink="true">http://pzel.github.io/til/2018/03/20/Elixir-cmd-star-expansion.html</guid>
      </item>
    
      <item>
        <title>Folding on cowboy_req</title>
        <description>Streamlined use of a streamlined API
	&lt;h2&gt;The problem&lt;/h2&gt;

&lt;p&gt;Pre-1.x versions of &lt;a href=&quot;https://github.com/ninenines/cowboy&quot;&gt;cowboy&lt;/a&gt; have an elegant, minimalist, and uniform API for
grabbing data out of &lt;code&gt;http_req&lt;/code&gt; records. This API includes functions like:
&lt;code&gt;cowboy_req:header/3&lt;/code&gt;, &lt;code&gt;cowboy_req:qs_vals/1&lt;/code&gt;, etc.&lt;/p&gt;

&lt;p&gt;Their elegance and uniformity come from the fact that they all return the tuple
&lt;code&gt;{A, NewReq}&lt;/code&gt;, such that &lt;code&gt;A&lt;/code&gt; is the result of the function call, and &lt;code&gt;NewReq&lt;/code&gt;
is the potentially-transformed, new request record that you should use
thereafter.&lt;/p&gt;

&lt;p&gt;Suppose your business requirements dictate that you have to gather a lot of
data from a request, and then &lt;code&gt;do_something()&lt;/code&gt; with it. What ends up happening
is that your code begins to look like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{OriginalIp, Req1} = cowboy_req:header(&amp;lt;&amp;lt;&quot;x-forwarded-for&quot;&amp;gt;&amp;gt;, Req, &amp;lt;&amp;lt;&amp;gt;&amp;gt;),
{UserAgent, Req2} = cowboy_req:header(&amp;lt;&amp;lt;&quot;user-agent&quot;&amp;gt;&amp;gt;, Req1, &amp;lt;&amp;lt;&amp;gt;&amp;gt;),
{QsVals, Req3} = cowboy_req:qs_vals(Req2),
{Path, Req4} = cowboy_req:path(Req4),
Reply = do_something(OriginalIp, UserAgent, QsVals, Path),
{ok, Reply, Req4}.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This gets tedious fast, and causes problems if you want to add or remove some
of the intermediate steps. For example: removing the assignment to &lt;code&gt;Req2&lt;/code&gt; would
force you to rename all following variables, or leave a 'hole' and rename
&lt;code&gt;Req1&lt;/code&gt; to &lt;code&gt;Req2&lt;/code&gt; in the previous line. Inelegant options, both.&lt;/p&gt;

&lt;h2&gt;The solution&lt;/h2&gt;

&lt;p&gt;As the wonderful &lt;a href=&quot;http://www.cs.nott.ac.uk/~pszgmh/fold.pdf&quot;&gt;tutorial on the universality and expresiveness of fold&lt;/a&gt; will
tell you, &lt;code&gt;fold&lt;/code&gt; is the best function. We can clean up the above code and
remove our useless assignments to numbered variables by using the following
pattern.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{[OriginalIp, UserAgent, QsVals, Path], NewReq} =
  fold_req([fun(R) -&amp;gt; cowboy_req:header(&amp;lt;&amp;lt;&quot;x-forwarded-for&quot;&amp;gt;&amp;gt;, R, &amp;lt;&amp;lt;&amp;gt;&amp;gt;) end,
            fun(R) -&amp;gt; cowboy_req:header(&amp;lt;&amp;lt;&quot;user-agent&quot;&amp;gt;&amp;gt;, R, &amp;lt;&amp;lt;&amp;gt;&amp;gt;) end,
            fun(R) -&amp;gt; cowboy_req:qs_vals(R) end,
            fun(R) -&amp;gt; cowboy_req:path(R) end]
            Req),
Reply = do_something(OriginalIp, UserAgent, QsVals, Path),
{ok, Reply, NewReq}.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yes, that's 2 extra lines of overhead, but the gain is that we don't have to
keep track of the various &lt;code&gt;Req&lt;/code&gt;s that abound in the code above.&lt;/p&gt;

&lt;p&gt;All of the functions in the chain are completely independent, and we can add or
remove them as we see fit, without having to rearrange all the code.&lt;/p&gt;

&lt;h2&gt;The implemenation&lt;/h2&gt;

&lt;p&gt;The implementation of &lt;code&gt;fold_req/2&lt;/code&gt; is trivial, so if you're up for the task,
&lt;strong&gt;try to write it yourself, now&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Scroll below to see my take on the solution.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;----------------------------------------------------------














--------------------- SPOILERS BELOW ---------------------














----------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;The actual implementation&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;fold_req(Funs, Req) -&amp;gt; 
    lists:foldr(fun fold_step/2, {[], Req}, Funs).

fold_step(Fun, {Acc, Req}) -&amp;gt;
    {Val, NewReq} = Fun(Req),
    {[Val|Acc], NewReq}.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cheers!&lt;/p&gt;

	</description>
        <pubDate>Mon, 05 Feb 2018 00:00:00 +0100</pubDate>
        <link>http://pzel.github.io/2018/02/05/Folding-on-cowboy_req.html</link>
        <guid isPermaLink="true">http://pzel.github.io/2018/02/05/Folding-on-cowboy_req.html</guid>
      </item>
    
      <item>
        <title>Mysterious 'bad_return' from supervisor</title>
        <description>
	&lt;p&gt;I was recently evaulating this &lt;a href=&quot;https://github.com/tkyshm/efluentc&quot;&gt;erlang fluentd
client&lt;/a&gt; and got the following error when
running &lt;code&gt;rebar3 ct&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%%% efluentc_SUITE ==&amp;gt; {tc_auto_skip,
 {failed,
  {efluentc_SUITE,init_per_suite,
   {'EXIT',
    {{badmatch,
      {error,
       {efluentc,
        {bad_return,
         {{efluentc_app,start,[normal,[]]},
          {'EXIT',
           {noproc,
            {gen_server,call,[efluentc_sup,{start_child,[0]},infinity]}}}}}}}},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What's a &lt;code&gt;bad_return&lt;/code&gt;? It happens when the &lt;code&gt;init/1&lt;/code&gt; function in a supervisor
module returns an invalid &lt;a href=&quot;http://erlang.org/doc/man/supervisor.html#Module:init-1&quot;&gt;supervisor
spec&lt;/a&gt;. Still, the
&lt;a href=&quot;https://travis-ci.org/tkyshm/efluentc&quot;&gt;project's Travis page&lt;/a&gt; shows the build
as green! What gives?&lt;/p&gt;

&lt;p&gt;It turns out that while the version of Erlang that I had been running, 17.5,
supports maps, it does &lt;strong&gt;not&lt;/strong&gt; support the relatively new map-based supervisor
spec API.&lt;/p&gt;

&lt;p&gt;This spec was causing the error:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%% Supervisor callbacks
init([]) -&amp;gt;
    SupFlags = #{
      strategy  =&amp;gt; simple_one_for_one,
      intensity =&amp;gt; 1000,
      period    =&amp;gt; 3600
    },

    Child = #{
      id       =&amp;gt; 'efluentc_client',
      start    =&amp;gt; {'efluentc_client', start_link, []},
      restart  =&amp;gt; permanent,
      shutdown =&amp;gt; 2000,
      type     =&amp;gt; worker,
      modules  =&amp;gt; ['efluentc_client']
    },

    {ok, {SupFlags, [Child]}}.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;If you're having problems with supervisors crashing with &lt;code&gt;bad_return&lt;/code&gt;s, check
your Erlang/OTP version. Map-based specs were added in &lt;a href=&quot;http://www.erlang.org/news/86&quot;&gt;Erlang
18&lt;/a&gt;.&lt;/p&gt;

	</description>
        <pubDate>Fri, 02 Feb 2018 00:00:00 +0100</pubDate>
        <link>http://pzel.github.io/til/2018/02/02/Bad-return-from-supervisor.html</link>
        <guid isPermaLink="true">http://pzel.github.io/til/2018/02/02/Bad-return-from-supervisor.html</guid>
      </item>
    
      <item>
        <title>cowboy_req:reply works by side-effect!</title>
        <description>
	&lt;p&gt;Let's say you have the following &lt;a href=&quot;https://github.com/ninenines/cowboy&quot;&gt;cowboy&lt;/a&gt; handler:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;reply_with_things(Things, Req, State) -&amp;gt;
    {ok, Req1} = cowboy_req:reply(200,
        [{&amp;lt;&amp;lt;&quot;content-type&quot;&amp;gt;&amp;gt;, &amp;lt;&amp;lt;&quot;application/json&quot;&amp;gt;&amp;gt;}],
        jiffy:encode({[{things, Things}]}), Req),
    _ = some_action(Things),
    {ok, Req1, State}.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and &lt;code&gt;some_action/1&lt;/code&gt; crashes. What gets returned to the client?&lt;/p&gt;

&lt;p&gt;In turns out that the client will still get the encoded json response, as
&lt;code&gt;cowboy_req:reply&lt;/code&gt; works by side-effect.&lt;/p&gt;

&lt;p&gt;Not that you'd want to have code like the above in your system. It's here just
for educational purposes.&lt;/p&gt;

	</description>
        <pubDate>Tue, 30 Jan 2018 00:00:00 +0100</pubDate>
        <link>http://pzel.github.io/til/2018/01/30/Cowboy-replies.html</link>
        <guid isPermaLink="true">http://pzel.github.io/til/2018/01/30/Cowboy-replies.html</guid>
      </item>
    
  </channel>
</rss>
